Tengo una app con rust y este servicio 

use crate::db::mongodb::MongoDbContext;
use mongodb::bson::{doc, Document, oid::ObjectId, Regex};
use crate::modules::market_pair::market_pair_schema::MarketPair;
use tracing::error;
use chrono::Utc;
use futures::TryStreamExt;
use serde::{Serialize, Deserialize};
use mongodb::bson;

use crate::modules::asset::asset_schema::Asset;
use crate::modules::exchange::exchange_schema::Exchange;

pub struct MarketPairService;

#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct PopulatedMarketPair {
    #[serde(rename = "_id", skip_serializing_if = "Option::is_none")]
    pub id: Option<ObjectId>,
    pub exchange: Exchange,
    pub base_asset: Asset,
    pub quote_asset: Asset,
    pub created_at: f64,
    pub updated_at: f64,
    pub status: bool,
}


impl MarketPairService {
    pub async fn create_market_pair(market_pair: MarketPair, db_context: &MongoDbContext) -> Result<MarketPair, String> {
        let db = db_context.get_database();
        let collection = db.collection::<MarketPair>("marketpairs");

        let now = Utc::now().timestamp() as f64;
        let new_market_pair = MarketPair {
            created_at: now,
            updated_at: now,
            ..market_pair
        };

        let insert_result = collection.insert_one(new_market_pair.clone()).await
            .map_err(|e| {
                error!("Failed to insert market pair: {}", e);
                e.to_string()
            })?;
        
        let new_market_pair = collection.find_one(doc! { "_id": insert_result.inserted_id }).await
            .map_err(|e| {
                error!("Failed to fetch created market pair: {}", e);
                e.to_string()
            })?
            .ok_or_else(|| {
                let msg = "Failed to fetch created market pair".to_string();
                error!("{}", msg);
                msg
            })?;
        
        Ok(new_market_pair)
    }

    pub async fn get_market_pair(id: ObjectId, db_context: &MongoDbContext) -> Result<MarketPair, String> {
        let db = db_context.get_database();
        let collection = db.collection::<MarketPair>("marketpairs");

        let market_pair = collection.find_one(doc! { "_id": id }).await
            .map_err(|e| {
                error!("Failed to fetch market pair: {}", e);
                e.to_string()
            })?
            .ok_or_else(|| {
                let msg = "Market pair not found".to_string();
                error!("{}", msg);
                msg
            })?;

        Ok(market_pair)
    }

    pub async fn update_market_pair(id: ObjectId, updated_market_pair: MarketPair, db_context: &MongoDbContext) -> Result<MarketPair, String> {
        let db = db_context.get_database();
        let collection = db.collection::<MarketPair>("marketpairs");

        let now = Utc::now().timestamp();
        let update_doc = doc! {
            "$set": {
                "_exchange": updated_market_pair._exchange,
                "_base_asset": updated_market_pair._base_asset,
                "_quote_asset": updated_market_pair._quote_asset,
                "updated_at": now,
                "status": updated_market_pair.status,
            }
        };

        collection.update_one(doc! { "_id": id }, update_doc).await
            .map_err(|e| {
                error!("Failed to update market pair: {}", e);
                e.to_string()
            })?;

        Self::get_market_pair(id, db_context).await
    }

    pub async fn delete_market_pair(id: ObjectId, db_context: &MongoDbContext) -> Result<(), String> {
        let db = db_context.get_database();
        let collection = db.collection::<MarketPair>("marketpairs");

        collection.delete_one(doc! { "_id": id }).await
            .map_err(|e| {
                error!("Failed to delete market pair: {}", e);
                e.to_string()
            })?;

        Ok(())
    }

    pub async fn get_all_market_pairs(
        db_context: &MongoDbContext,
        page: u64,
        per_page: u64,
        exchange_id: Option<String>,
        search: Option<String>
    ) -> Result<(Vec<PopulatedMarketPair>, u64), String> {
        let db = db_context.get_database();
        let market_pairs_collection = db.collection::<Document>("marketpairs");
    
        let skip = (page - 1) * per_page;
    
        let mut initial_filter = doc! {};
    
        if let Some(exchange) = exchange_id.filter(|s| !s.is_empty()) {
            if let Ok(oid) = ObjectId::parse_str(&exchange) {
                initial_filter.insert("_exchange", oid);
            }
        }
    
        let mut pipeline = vec![
            doc! { "$match": initial_filter },
            doc! {
                "$lookup": {
                    "from": "exchanges",
                    "localField": "_exchange",
                    "foreignField": "_id",
                    "as": "exchange"
                }
            },
            doc! {
                "$lookup": {
                    "from": "assets",
                    "localField": "_base_asset",
                    "foreignField": "_id",
                    "as": "base_asset"
                }
            },
            doc! {
                "$lookup": {
                    "from": "assets",
                    "localField": "_quote_asset",
                    "foreignField": "_id",
                    "as": "quote_asset"
                }
            },
            doc! { "$unwind": "$exchange" },
            doc! { "$unwind": "$base_asset" },
            doc! { "$unwind": "$quote_asset" },
        ];
    
        if let Some(term) = search.filter(|s| !s.is_empty()) {
            let search_stage = doc! {
                "$match": {
                    "$or": [
                        { "base_asset.short_name": Regex { pattern: format!(".*{}.*", term), options: "i".to_string() } },
                        { "quote_asset.short_name": Regex { pattern: format!(".*{}.*", term), options: "i".to_string() } }
                    ]
                }
            };
            pipeline.push(search_stage);
        }
    
        pipeline.push(doc! { "$skip": skip as i64 });
        pipeline.push(doc! { "$limit": per_page as i64 });
    
        let mut cursor = market_pairs_collection.aggregate(pipeline.clone()).await
            .map_err(|e| {
                error!("Failed to aggregate market pairs: {}", e);
                e.to_string()
            })?;
    
        let mut populated_market_pairs = Vec::new();
        while let Some(result) = cursor.try_next().await.map_err(|e| {
            error!("Failed to iterate through aggregation results: {}", e);
            e.to_string()
        })? {
            let populated_market_pair: PopulatedMarketPair = bson::from_document(result)
                .map_err(|e| {
                    error!("Failed to deserialize market pair: {}", e);
                    e.to_string()
                })?;
    
            populated_market_pairs.push(populated_market_pair);
        }
    
        // Para contar el total, necesitamos quitar las etapas de paginación y agregar un $count
        pipeline.pop(); // Quitar $limit
        pipeline.pop(); // Quitar $skip
        pipeline.push(doc! { "$count": "total" });
    
        let total = market_pairs_collection.aggregate(pipeline).await
            .map_err(|e| {
                error!("Failed to count market pairs: {}", e);
                e.to_string()
            })?
            .try_next().await
            .map_err(|e| {
                error!("Failed to get count result: {}", e);
                e.to_string()
            })?
            .and_then(|doc| doc.get_i64("total").ok())
            .unwrap_or(0) as u64;
    
        Ok((populated_market_pairs, total))
    }
}


con este controlador

use actix_web::{get, post, put, delete, web, HttpResponse, Responder};
use crate::modules::market_pair::market_pair_service::MarketPairService;
use crate::db::mongodb::MongoDbContext;
use crate::modules::market_pair::market_pair_schema::MarketPair;
use mongodb::bson::oid::ObjectId;
use serde::{Deserialize};
use crate::modules::auth::auth_response::ApiResponse;
use tracing::{error};
use serde_json::json;

#[derive(Deserialize)]
struct ObjectIdPath {
    id: String,
}

#[derive(Deserialize)]
struct MarketPairQuery {
    page: Option<u64>,
    per_page: Option<u64>,
    exchange_id: Option<String>,
    search: Option<String>,
}


#[post("/market_pairs")]
pub async fn create_market_pair(market_pair: web::Json<MarketPair>, db_context: web::Data<MongoDbContext>) -> impl Responder {
    match MarketPairService::create_market_pair(market_pair.into_inner(), &db_context).await {
        Ok(market_pair) => HttpResponse::Ok().json(ApiResponse::success("Market pair created successfully", market_pair)),
        Err(err) => {
            error!("Failed to create market pair in : {}", err);
            HttpResponse::BadRequest().json(ApiResponse::<String>::error(&err))
        },
    }
}

#[get("/market_pairs/{id}")]
pub async fn get_market_pair(path: web::Path<ObjectIdPath>, db_context: web::Data<MongoDbContext>) -> impl Responder {
    let id = ObjectId::parse_str(&path.id).expect("Invalid ObjectId");
    match MarketPairService::get_market_pair(id, &db_context).await {
        Ok(market_pair) => HttpResponse::Ok().json(ApiResponse::success("Market pair retrieved successfully", market_pair)),
        Err(err) => {
            error!("Failed to retrieve market pair: {}", err);
            HttpResponse::NotFound().json(ApiResponse::<String>::error(&err))
        },
    }
}

#[put("/market_pairs/{id}")]
pub async fn update_market_pair(path: web::Path<ObjectIdPath>, market_pair: web::Json<MarketPair>, db_context: web::Data<MongoDbContext>) -> impl Responder {
    let id = ObjectId::parse_str(&path.id).expect("Invalid ObjectId");
    match MarketPairService::update_market_pair(id, market_pair.into_inner(), &db_context).await {
        Ok(market_pair) => HttpResponse::Ok().json(ApiResponse::success("Market pair updated successfully", market_pair)),
        Err(err) => {
            error!("Failed to update market pair: {}", err);
            HttpResponse::BadRequest().json(ApiResponse::<String>::error(&err))
        },
    }
}

#[delete("/market_pairs/{id}")]
pub async fn delete_market_pair(path: web::Path<ObjectIdPath>, db_context: web::Data<MongoDbContext>) -> impl Responder {
    let id = ObjectId::parse_str(&path.id).expect("Invalid ObjectId");
    match MarketPairService::delete_market_pair(id, &db_context).await {
        Ok(_) => HttpResponse::Ok().json(ApiResponse::success("Market pair deleted successfully", ())),
        Err(err) => {
            error!("Failed to delete market pair: {}", err);
            HttpResponse::BadRequest().json(ApiResponse::<String>::error(&err))
        },
    }
}

#[get("/market_pairs")]
pub async fn get_all_market_pairs(
    db_context: web::Data<MongoDbContext>,
    query: web::Query<MarketPairQuery>,
) -> impl Responder {
    let page = query.page.unwrap_or(1);
    let per_page = query.per_page.unwrap_or(20);

    match MarketPairService::get_all_market_pairs(
        &db_context,
        page,
        per_page,
        query.exchange_id.clone(),
        query.search.clone(),
    ).await {
        Ok((market_pairs, total)) => HttpResponse::Ok().json(ApiResponse::success("Market pairs retrieved successfully", json!({
            "market_pairs": market_pairs,
            "total": total,
            "page": page,
            "per_page": per_page
        }))),
        Err(err) => {
            error!("Failed to retrieve market pairs in GET /market_pairs: {}", err);
            HttpResponse::BadRequest().json(ApiResponse::<String>::error(&err))
        },
    }
}

y este asset_schema

use serde::{Serialize, Deserialize};
use mongodb::bson::oid::ObjectId;

#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct MarketPair {
    #[serde(rename = "_id", skip_serializing_if = "Option::is_none")]
    pub id: Option<ObjectId>,
    pub _exchange: ObjectId,
    pub _base_asset: ObjectId,
    pub _quote_asset: ObjectId,
    pub created_at: f64,
    pub updated_at: f64,
    pub status: bool,
}

pero estoy obteniendo un error debido a que cambié recientemente la schema 

pub created_at: f64,
    pub updated_at: f64, de i64 a f64

    como lo puedo solucionar
