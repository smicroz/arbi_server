use actix_web::{get, post, put, delete, web, HttpResponse, Responder};
use crate::modules::arbitrage_strategy::arbitrage_strategy_service::ArbitrageStrategyService;
use crate::db::mongodb::MongoDbContext;
use crate::modules::arbitrage_strategy::arbitrage_strategy_schema::{ArbitrageStrategy, ArbitrageType};
use mongodb::bson::oid::ObjectId;
use serde::{Deserialize};
use crate::modules::auth::auth_response::ApiResponse;
use tracing::error;
use serde_json::json;

#[derive(Deserialize)]
struct ObjectIdPath {
    id: String,
}

#[derive(Deserialize)]
struct ArbitrageStrategyQuery {
    page: Option<u64>,
    per_page: Option<u64>,
    arbitrage_type: Option<ArbitrageType>,
}

#[post("/arbitrage-strategies")]
pub async fn create_arbitrage_strategy(strategy: web::Json<ArbitrageStrategy>, db_context: web::Data<MongoDbContext>) -> impl Responder {
    match ArbitrageStrategyService::create_arbitrage_strategy(strategy.into_inner(), &db_context).await {
        Ok(strategy) => HttpResponse::Ok().json(ApiResponse::success("Arbitrage strategy created successfully", strategy)),
        Err(err) => {
            error!("Failed to create arbitrage strategy: {}", err);
            HttpResponse::BadRequest().json(ApiResponse::<String>::error(&err))
        },
    }
}

#[get("/arbitrage-strategies/{id}")]
pub async fn get_arbitrage_strategy(path: web::Path<ObjectIdPath>, db_context: web::Data<MongoDbContext>) -> impl Responder {
    let id = ObjectId::parse_str(&path.id).expect("Invalid ObjectId");
    match ArbitrageStrategyService::get_arbitrage_strategy(id, &db_context).await {
        Ok(strategy) => HttpResponse::Ok().json(ApiResponse::success("Arbitrage strategy retrieved successfully", strategy)),
        Err(err) => {
            error!("Failed to retrieve arbitrage strategy: {}", err);
            HttpResponse::NotFound().json(ApiResponse::<String>::error(&err))
        },
    }
}

#[put("/arbitrage-strategies/{id}")]
pub async fn update_arbitrage_strategy(path: web::Path<ObjectIdPath>, strategy: web::Json<ArbitrageStrategy>, db_context: web::Data<MongoDbContext>) -> impl Responder {
    let id = ObjectId::parse_str(&path.id).expect("Invalid ObjectId");
    match ArbitrageStrategyService::update_arbitrage_strategy(id, strategy.into_inner(), &db_context).await {
        Ok(strategy) => HttpResponse::Ok().json(ApiResponse::success("Arbitrage strategy updated successfully", strategy)),
        Err(err) => {
            error!("Failed to update arbitrage strategy: {}", err);
            HttpResponse::BadRequest().json(ApiResponse::<String>::error(&err))
        },
    }
}

#[delete("/arbitrage-strategies/{id}")]
pub async fn delete_arbitrage_strategy(path: web::Path<ObjectIdPath>, db_context: web::Data<MongoDbContext>) -> impl Responder {
    let id = ObjectId::parse_str(&path.id).expect("Invalid ObjectId");
    match ArbitrageStrategyService::delete_arbitrage_strategy(id, &db_context).await {
        Ok(_) => HttpResponse::Ok().json(ApiResponse::success("Arbitrage strategy deleted successfully", ())),
        Err(err) => {
            error!("Failed to delete arbitrage strategy: {}", err);
            HttpResponse::BadRequest().json(ApiResponse::<String>::error(&err))
        },
    }
}

#[get("/arbitrage-strategies")]
pub async fn get_all_arbitrage_strategies(
    db_context: web::Data<MongoDbContext>,
    query: web::Query<ArbitrageStrategyQuery>,
) -> impl Responder {
    let page = query.page.unwrap_or(1);
    let per_page = query.per_page.unwrap_or(20);

    match ArbitrageStrategyService::get_all_arbitrage_strategies(
        &db_context,
        page,
        per_page,
        query.arbitrage_type.clone(),
    ).await {
        Ok((strategies, total)) => HttpResponse::Ok().json(ApiResponse::success("Arbitrage strategies retrieved successfully", json!({
            "strategies": strategies,
            "total": total,
            "page": page,
            "per_page": per_page
        }))),
        Err(err) => {
            error!("Failed to retrieve arbitrage strategies: {}", err);
            HttpResponse::BadRequest().json(ApiResponse::<String>::error(&err))
        },
    }
}

y

use crate::db::mongodb::MongoDbContext;
use mongodb::bson::{doc, Document, oid::ObjectId};
use crate::modules::arbitrage_strategy::arbitrage_strategy_schema::{ArbitrageStrategy, ArbitrageType, ArbitrageDetails};
use tracing::error;
use chrono::Utc;
use futures::TryStreamExt;
use serde_json::json;
use mongodb::bson;

pub struct ArbitrageStrategyService;

impl ArbitrageStrategyService {
    pub async fn create_arbitrage_strategy(strategy: ArbitrageStrategy, db_context: &MongoDbContext) -> Result<ArbitrageStrategy, String> {
        let db = db_context.get_database();
        let collection = db.collection::<ArbitrageStrategy>("arbitrage_strategies");

        let now = Utc::now().timestamp() as f64;
        let new_strategy = ArbitrageStrategy {
            created_at: now,
            updated_at: now,
            ..strategy
        };

        let insert_result = collection.insert_one(new_strategy.clone()).await
            .map_err(|e| {
                error!("Failed to insert arbitrage strategy: {}", e);
                e.to_string()
            })?;
        
        let new_strategy = collection.find_one(doc! { "_id": insert_result.inserted_id }).await
            .map_err(|e| {
                error!("Failed to fetch created arbitrage strategy: {}", e);
                e.to_string()
            })?
            .ok_or_else(|| {
                let msg = "Failed to fetch created arbitrage strategy".to_string();
                error!("{}", msg);
                msg
            })?;
        
        Ok(new_strategy)
    }

    pub async fn get_arbitrage_strategy(id: ObjectId, db_context: &MongoDbContext) -> Result<ArbitrageStrategy, String> {
        let db = db_context.get_database();
        let collection = db.collection::<ArbitrageStrategy>("arbitrage_strategies");

        let strategy = collection.find_one(doc! { "_id": id }).await
            .map_err(|e| {
                error!("Failed to fetch arbitrage strategy: {}", e);
                e.to_string()
            })?
            .ok_or_else(|| {
                let msg = "Arbitrage strategy not found".to_string();
                error!("{}", msg);
                msg
            })?;

        Ok(strategy)
    }

    pub async fn update_arbitrage_strategy(id: ObjectId, updated_strategy: ArbitrageStrategy, db_context: &MongoDbContext) -> Result<ArbitrageStrategy, String> {
        let db = db_context.get_database();
        let collection = db.collection::<ArbitrageStrategy>("arbitrage_strategies");

        let now = Utc::now().timestamp() as f64;
        let update_doc = doc! {
            "$set": {
                "arbitrage_type": bson::to_bson(&updated_strategy.arbitrage_type)?,
                "details": bson::to_bson(&updated_strategy.details)?,
                "updated_at": now,
                "status": updated_strategy.status,
            }
        };

        collection.update_one(doc! { "_id": id }, update_doc).await
            .map_err(|e| {
                error!("Failed to update arbitrage strategy: {}", e);
                e.to_string()
            })?;

        Self::get_arbitrage_strategy(id, db_context).await
    }

    pub async fn delete_arbitrage_strategy(id: ObjectId, db_context: &MongoDbContext) -> Result<(), String> {
        let db = db_context.get_database();
        let collection = db.collection::<ArbitrageStrategy>("arbitrage_strategies");

        collection.delete_one(doc! { "_id": id }).await
            .map_err(|e| {
                error!("Failed to delete arbitrage strategy: {}", e);
                e.to_string()
            })?;

        Ok(())
    }

    pub async fn get_all_arbitrage_strategies(
        db_context: &MongoDbContext,
        page: u64,
        per_page: u64,
        arbitrage_type: Option<ArbitrageType>,
    ) -> Result<(Vec<ArbitrageStrategy>, u64), String> {
        let db = db_context.get_database();
        let collection = db.collection::<ArbitrageStrategy>("arbitrage_strategies");

        let skip = (page - 1) * per_page;
        
        let mut filter = doc! {};
        if let Some(arb_type) = arbitrage_type {
            filter.insert("arbitrage_type", bson::to_bson(&arb_type)?);
        }

        let mut cursor = collection.find(filter.clone()).skip(skip as u64).limit(per_page as i64).await
            .map_err(|e| {
                error!("Failed to fetch arbitrage strategies: {}", e);
                e.to_string()
            })?;

        let mut strategies = Vec::new();
        while let Some(strategy) = cursor.try_next().await.map_err(|e| {
            error!("Failed to iterate through arbitrage strategies: {}", e);
            e.to_string()
        })? {
            strategies.push(strategy);
        }

        let total = collection.count_documents(filter).await
            .map_err(|e| {
                error!("Failed to count arbitrage strategies: {}", e);
                e.to_string()
            })?;

        Ok((strategies, total))
    }
}

Tengo algunos errores:

error[E0277]: `?` couldn't convert the error to `std::string::String`
  --> src/modules/arbitrage_strategy/arbitrage_strategy_service.rs:69:82
   |
69 |                 "arbitrage_type": bson::to_bson(&updated_strategy.arbitrage_type)?,
   |                                                                                  ^ the trait `std::convert::From<mongodb::bson::ser::Error>` is not implemented for `std::string::String`, which is required by `Result<ArbitrageStrategy, std::string::String>: FromResidual<Result<Infallible, mongodb::bson::ser::Error>>`
   |
   = note: the question mark operation (`?`) implicitly performs a conversion on the error value using the `From` trait
   = help: the following other types implement trait `std::convert::From<T>`:
             <std::string::String as std::convert::From<&mut str>>
             <std::string::String as std::convert::From<&std::string::String>>
             <std::string::String as std::convert::From<&str>>
             <std::string::String as std::convert::From<Box<str>>>
             <std::string::String as std::convert::From<Cow<'a, str>>>
             <std::string::String as std::convert::From<bytestring::ByteString>>
             <std::string::String as std::convert::From<char>>
             <std::string::String as std::convert::From<trust_dns_proto::error::ProtoError>>
           and 2 others
   = note: required for `Result<ArbitrageStrategy, std::string::String>` to implement `FromResidual<Result<Infallible, mongodb::bson::ser::Error>>`

error[E0277]: `?` couldn't convert the error to `std::string::String`
  --> src/modules/arbitrage_strategy/arbitrage_strategy_service.rs:70:68
   |
70 |                 "details": bson::to_bson(&updated_strategy.details)?,
   |                                                                    ^ the trait `std::convert::From<mongodb::bson::ser::Error>` is not implemented for `std::string::String`, which is required by `Result<ArbitrageStrategy, std::string::String>: FromResidual<Result<Infallible, mongodb::bson::ser::Error>>`
   |
   = note: the question mark operation (`?`) implicitly performs a conversion on the error value using the `From` trait
   = help: the following other types implement trait `std::convert::From<T>`:
             <std::string::String as std::convert::From<&mut str>>
             <std::string::String as std::convert::From<&std::string::String>>
             <std::string::String as std::convert::From<&str>>
             <std::string::String as std::convert::From<Box<str>>>
             <std::string::String as std::convert::From<Cow<'a, str>>>
             <std::string::String as std::convert::From<bytestring::ByteString>>
             <std::string::String as std::convert::From<char>>
             <std::string::String as std::convert::From<trust_dns_proto::error::ProtoError>>
           and 2 others
   = note: required for `Result<ArbitrageStrategy, std::string::String>` to implement `FromResidual<Result<Infallible, mongodb::bson::ser::Error>>`

error[E0277]: `?` couldn't convert the error to `std::string::String`
   --> src/modules/arbitrage_strategy/arbitrage_strategy_service.rs:111:69
    |
111 |             filter.insert("arbitrage_type", bson::to_bson(&arb_type)?);
    |                                                                     ^ the trait `std::convert::From<mongodb::bson::ser::Error>` is not implemented for `std::string::String`, which is required by `Result<(Vec<ArbitrageStrategy>, u64), std::string::String>: FromResidual<Result<Infallible, mongodb::bson::ser::Error>>`
    |
    = note: the question mark operation (`?`) implicitly performs a conversion on the error value using the `From` trait
    = help: the following other types implement trait `std::convert::From<T>`:
              <std::string::String as std::convert::From<&mut str>>
              <std::string::String as std::convert::From<&std::string::String>>
              <std::string::String as std::convert::From<&str>>
              <std::string::String as std::convert::From<Box<str>>>
              <std::string::String as std::convert::From<Cow<'a, str>>>
              <std::string::String as std::convert::From<bytestring::ByteString>>
              <std::string::String as std::convert::From<char>>
              <std::string::String as std::convert::From<trust_dns_proto::error::ProtoError>>
            and 2 others
    = note: required for `Result<(Vec<ArbitrageStrategy>, u64), std::string::String>` to implement `FromResidual<Result<Infallible, mongodb::bson::ser::Error>>`